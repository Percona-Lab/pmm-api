package generator

import (
	"text/template"
)

type (
	prologTemplateData struct {
		SourceFile    string
		ProtocVersion string
		Version       string
		PackageName   string
	}

	method struct {
		Name       string
		InputType  string
		OutputType string
	}

	templateData struct {
		PackageName           string
		ServiceName           string
		ServiceNameUnexported string
		Methods               []method
	}
)

var (
	prologTemplate = template.Must(template.New("prolog").Parse(`
// Code generated by protoc-gen-wsrpc. DO NOT EDIT.
// source: {{ .SourceFile }}
// protoc version: {{ .ProtocVersion }}
// protoc-gen-wsrpc version: {{ .Version }}

package {{ .PackageName }}

import (
	"github.com/golang/protobuf/proto"
	"github.com/Percona-Lab/wsrpc"
	"github.com/pkg/errors"
)
`))

	clientTemplate = template.Must(template.New("client").Parse(`
// Client API for {{ .PackageName }}.{{ .ServiceName }} service

type {{ .ServiceName }}Client interface {
	{{ range .Methods }}

	{{ .Name }}(*{{ .InputType }}) (*{{ .OutputType }}, error)

	{{ end }}
}

type {{ .ServiceNameUnexported }}Client struct {
	conn *wsrpc.Conn
}

func New{{ .ServiceName }}Client(conn *wsrpc.Conn) {{ .ServiceName }}Client {
	return &{{ .ServiceNameUnexported }}Client{conn}
}

{{ range .Methods }}

func (c *{{ $.ServiceNameUnexported }}Client) {{ .Name }}(req *{{ .InputType }}) (*{{ .OutputType }}, error) {
	b, err := proto.Marshal(req)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", req)
	}
	if b, err = c.conn.Invoke("{{ .Name }}", b); err != nil {
		return nil, err
	}
	res := new({{ .OutputType }})
	if err = proto.Unmarshal(b, res); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", res)
	}
	return res, nil
}

{{ end }}

// check interface
var _ {{ .ServiceName }}Client = (*{{ $.ServiceNameUnexported }}Client)(nil)
`))

	serverTemplate = template.Must(template.New("server").Parse(`
// Server API for {{ .PackageName }}.{{ .ServiceName }} service

type {{ .ServiceName }}Server interface {
	{{ range .Methods }}

	{{ .Name }}(*{{ .InputType }}) (*{{ .OutputType }}, error)

	{{ end }}
}

type {{ .ServiceName }}Dispatcher struct {
	conn   *wsrpc.Conn
	server {{ .ServiceName }}Server
}

func New{{ .ServiceName }}Dispatcher(conn *wsrpc.Conn, server {{ .ServiceName }}Server) *{{ .ServiceName }}Dispatcher {
	return &{{ .ServiceName }}Dispatcher{conn, server}
}

{{ range .Methods }}

func dispatch{{ .Name }}(server interface{}, arg []byte) ([]byte, error) {
	req := new({{ .InputType }})
	if err := proto.Unmarshal(arg, req); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", req)
	}
	res, err := server.({{ $.ServiceName }}Server).{{ .Name }}(req)
	if err != nil {
		return nil, err
	}
	b, err := proto.Marshal(res)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", res)
	}
	return b, nil
}

{{ end }}

var {{ .ServiceNameUnexported }}Description = &wsrpc.ServiceDesc{
	Methods: []wsrpc.ServiceMethod{
{{ range .Methods -}}
		{
			Name:   "{{ .Name }}",
			Method: dispatch{{ .Name }},
		},
	},
{{ end }}
}

func (d *{{ .ServiceName }}Dispatcher) Run() (exitErr error) {
	for {
		message, err := d.conn.Read()
		if err != nil {
			exitErr = errors.Wrap(err, "failed to read message")
			return
		}

		var found bool
		for _, method := range {{ .ServiceNameUnexported }}Description.Methods {
			if method.Name != message.Path {
				continue
			}

			res, err := method.Method(d.server, message.Arg)
			if err != nil {
				exitErr = errors.Wrapf(err, "%s returned error", method.Name)
				return
			}

			message = &wsrpc.Message{
				StreamID: message.StreamID,
				Path:     message.Path,
				Arg:      res,
			}
			if err = d.conn.Write(message); err != nil {
				// TODO close stream, not not the whole connection
				exitErr = errors.Wrap(err, "failed to write message")
				return
			}

			found = true
			break
		}

		if !found {
			exitErr = errors.Wrapf(err, "unexpected path %q", message.Path)
			return
		}
	}
}
`))
)
