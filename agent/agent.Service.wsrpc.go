// Code generated by protoc-gen-wsrpc. DO NOT EDIT.
// source: agent/agent.proto
// protoc version: 3.5.1
// protoc-gen-wsrpc version: 0.1.0-dev

package agent

import (
	"github.com/Percona-Lab/wsrpc"
	"github.com/golang/protobuf/proto"
	"github.com/pkg/errors"
)

// Client API for agent.Service service

type ServiceClient interface {
	CreateTunnel(*CreateTunnelRequest) (*CreateTunnelResponse, error)
	WriteToTunnel(*WriteToTunnelRequest) (*WriteToTunnelResponse, error)
}

type serviceClient struct {
	conn *wsrpc.Conn
}

func NewServiceClient(conn *wsrpc.Conn) ServiceClient {
	return &serviceClient{conn}
}

func (c *serviceClient) CreateTunnel(req *CreateTunnelRequest) (*CreateTunnelResponse, error) {
	b, err := proto.Marshal(req)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", req)
	}
	if b, err = c.conn.Invoke("CreateTunnel", b); err != nil {
		return nil, err
	}
	res := new(CreateTunnelResponse)
	if err = proto.Unmarshal(b, res); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", res)
	}
	return res, nil
}

func (c *serviceClient) WriteToTunnel(req *WriteToTunnelRequest) (*WriteToTunnelResponse, error) {
	b, err := proto.Marshal(req)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", req)
	}
	if b, err = c.conn.Invoke("WriteToTunnel", b); err != nil {
		return nil, err
	}
	res := new(WriteToTunnelResponse)
	if err = proto.Unmarshal(b, res); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", res)
	}
	return res, nil
}

// check interface
var _ ServiceClient = (*serviceClient)(nil)

// Server API for agent.Service service

type ServiceServer interface {
	CreateTunnel(*CreateTunnelRequest) (*CreateTunnelResponse, error)
	WriteToTunnel(*WriteToTunnelRequest) (*WriteToTunnelResponse, error)
}

type ServiceDispatcher struct {
	conn   *wsrpc.Conn
	server ServiceServer
}

func NewServiceDispatcher(conn *wsrpc.Conn, server ServiceServer) *ServiceDispatcher {
	return &ServiceDispatcher{conn, server}
}

func dispatchCreateTunnel(server interface{}, arg []byte) ([]byte, error) {
	req := new(CreateTunnelRequest)
	if err := proto.Unmarshal(arg, req); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", req)
	}
	res, err := server.(ServiceServer).CreateTunnel(req)
	if err != nil {
		return nil, err
	}
	b, err := proto.Marshal(res)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", res)
	}
	return b, nil
}

func dispatchWriteToTunnel(server interface{}, arg []byte) ([]byte, error) {
	req := new(WriteToTunnelRequest)
	if err := proto.Unmarshal(arg, req); err != nil {
		return nil, errors.Wrapf(err, "failed to unmarshal protobuf message to %T", req)
	}
	res, err := server.(ServiceServer).WriteToTunnel(req)
	if err != nil {
		return nil, err
	}
	b, err := proto.Marshal(res)
	if err != nil {
		return nil, errors.Wrapf(err, "failed to marshal protobuf message %T", res)
	}
	return b, nil
}

var serviceDescription = &wsrpc.ServiceDesc{
	Methods: []wsrpc.ServiceMethod{
		{
			Name:   "CreateTunnel",
			Method: dispatchCreateTunnel,
		},
		{
			Name:   "WriteToTunnel",
			Method: dispatchWriteToTunnel,
		},
	},
}

func (d *ServiceDispatcher) Run() (exitErr error) {
	for {
		message, err := d.conn.Read()
		if err != nil {
			exitErr = errors.Wrap(err, "failed to read message")
			return
		}

		var found bool
		for _, method := range serviceDescription.Methods {
			if method.Name != message.Path {
				continue
			}

			res, err := method.Method(d.server, message.Arg)
			if err != nil {
				exitErr = errors.Wrapf(err, "%s returned error", method.Name)
				return
			}

			message = &wsrpc.Message{
				StreamID: message.StreamID,
				Path:     message.Path,
				Arg:      res,
			}
			if err = d.conn.Write(message); err != nil {
				// TODO close stream, not not the whole connection
				exitErr = errors.Wrap(err, "failed to write message")
				return
			}

			found = true
			break
		}

		if !found {
			exitErr = errors.Wrapf(err, "unexpected path %q", message.Path)
			return
		}
	}
}
